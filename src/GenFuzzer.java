import java.io.*;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

public class GenFuzzer {

    public static void main(String [] args){

        byte[] data =initData();
        /* Crash about the width or the height */
        byte[] crashOne = genCrashData(data,17,(byte)0xB4);
        byte[] crashOneBis = genCrashData(data,17,(byte)0xEF);
        byte[] crashOneBisBis= genCrashData(data,11,(byte)0xC1);
        /* Crash about the number color */
        byte[] crashTwo = genCrashData(data,21,(byte)0xF2);
        byte[] crashTwoBis = genCrashData(data,21,(byte)0xE4);
        byte[] crashTwoBisBis = genCrashData(data,21,(byte)0xB3);
        /* Crash about author name */
        byte[] crashThree= genCrashData(data,9,(byte)0xD1);
        /**/
        byte[] crashFour= genCrashData(data,0,(byte)0x00);
        /**/
        byte[] crashFive= genCrashData(data,0,(byte)0x00);

        Path inputFile       = Paths.get("testInputGen1.img");
        Path inputFileTwo    = Paths.get("testInputGen2.img");
        Path inputFileThree  = Paths.get("testInputGen3.img");
        Path inputFileFour   = Paths.get("testInputGen4.img");
        Path inputFileFive   = Paths.get("testInputGen5.img");

         /*Write on the file the array of bytes*/
        try {
            Files.write(inputFile, crashOne);
            Files.write(inputFileTwo, crashTwo);
            Files.write(inputFileThree, crashThree);
            Files.write(inputFileFour, crashFour);
            Files.write(inputFileFive, crashFive);
        } catch (IOException e) {
            e.printStackTrace();
        }

         /*Run the converter_static exe*/
        String resultOfTheRun = run_process(inputFile);
        if (resultOfTheRun != null) {   // check if the result is not null
                 /*If the program is not crashing we delete the file*/
            if (!resultOfTheRun.equals("*** The program has crashed.")) {
                try {
                    Files.delete(inputFile);
                } catch (NoSuchFileException x) {
                    System.err.format("%s: no such" + " file or directory%n", inputFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private static byte[] genCrashData(byte[] data, int index, byte crashValue) {
        byte[] res = new byte[data.length];
        System.arraycopy( data, 0, res, 0, data.length );
        res[index]=crashValue;
        return res;
    }

    private static byte[] initData() {
        File fileName = new File("testinput.img");
        return read_file(fileName);
    }

    /**
     * Simply read the FIRST line of the result returned by the exec file.
     * @param inputFile the input file we give to the exec file.
     * @return the FIRST line of the result generated by the exec file.
     */
    private static String run_process(Path inputFile) {
        try {
            String line;
            Process p = Runtime.getRuntime().exec("./converter_static " + inputFile + " testoutput.img");
            BufferedReader bre = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            if ((line = bre.readLine()) != null) {
                return line;
            }
            bre.close();
            p.waitFor();
        }
        catch (Exception err) {
            err.printStackTrace();
        }
        return null;
    }

    /**
     * Read a file.
     * @param file: the file to read on.
     * @return a byte array from the file.
     */
    private static byte[] read_file(File file) {
        byte[] data = new byte[0];
        try {
            data = Files.readAllBytes(file.toPath());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return data;
    }
}


//
//    /* Magic Number */
//    dataOne[0]=(byte)0xAB;
//    dataOne[1]=(byte)0xCD;
//
//        /* Version */
//    dataOne[2]=(byte)0x00;
//    dataOne[3]=(byte)0x64;
//
//        /* Author name */
//    dataOne[4]=(byte)0x52;
//    dataOne[5]=(byte)0x61;
//    dataOne[6]=(byte)0x6d;
//    dataOne[7]=(byte)0x69;
//    dataOne[8]=(byte)0x6e;
//    dataOne[9]=(byte)0x00;
//
//        /* Width */
//    dataOne[10]=(byte)0x00;
//    dataOne[11]=(byte)0x00;
//    dataOne[12]=(byte)0x00;
//    dataOne[13]=(byte)0x10;
//
//        /* Height*/
//    dataOne[14]=(byte)0x00;
//    dataOne[15]=(byte)0x00;
//    dataOne[16]=(byte)0x00;
//    dataOne[17]=(byte)0x10;
//
//        /* Number of colors*/
//    dataOne[18]=(byte)0x00;
//    dataOne[19]=(byte)0x00;
//    dataOne[20]=(byte)0x00;
//    dataOne[21]=(byte)0x04;
//
//        /* Color 1 */
//    dataOne[22]=(byte)0xff;
//    dataOne[23]=(byte)0x00;
//    dataOne[24]=(byte)0x00;
//    dataOne[25]=(byte)0x00;
//
//        /* Color 2 */
//    dataOne[26]=(byte)0x00;
//    dataOne[27]=(byte)0xff;
//    dataOne[28]=(byte)0x00;
//    dataOne[29]=(byte)0xff;
//
//        /* Color 3 */
//    dataOne[30]=(byte)0x00;
//    dataOne[31]=(byte)0x00;
//    dataOne[32]=(byte)0x00;
//    dataOne[33]=(byte)0xff;
//
//        /* Color 4 */
//    dataOne[34]=(byte)0x00;
//    dataOne[35]=(byte)0x00;
//    dataOne[36]=(byte)0xff;
//    dataOne[37]=(byte)0x00;
//
//        for (int i = 41; i < dataOne.length; i++)
//    dataOne[i]= (byte) Math.floor(Math.random()*4);
//
